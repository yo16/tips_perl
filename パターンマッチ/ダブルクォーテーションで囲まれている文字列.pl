# 区切り文字で囲まれた文字にヒットする
#
# ※ ファイル名はダブルクォーテーションだけど、
#    実装がめんどいので、シングルにする！


# 1.短く取得するか。
$str = "'aaa','bbb'";

print "= 1 =\n";
if ( $str =~ /('[^']*')/ ) {
	print $1."\n";
} else {
	print "not found\n";
}
# 結論：期待通り'aaa'を取得できた



# 2.２つ連続でも取得できるか？

$str = "'','bbb'";

print "= 2 =\n";
if ( $str =~ /('[^']*')/ ) {
	print $1."\n";
} else {
	print "not found\n";
}
# 結論：期待通り''を取得できた
# でもこれは、エスケープ用の２個連続を優先したいので、
# 最終的には入力データエラーとしたい。



# 3.エスケープ用に２個連続登録されているの対応

$str = "'aaa''aa'";

print "= 3-1 =\n";
if ( $str =~ /('[^']*'[^']?)/ ) {
	print $1."\n";
} else {
	print "not found\n";
}
# 結論：ＮＧ。'aaa'になった。?つけると、なんでもいいになってしまうのかな。

print "= 3-2 =\n";
if ( $str =~ /('[^']*'[^'])/ ) {
	print $1."\n";
} else {
	print "not found\n";
}
# 結論：ＮＧ。''aになった。


# なんか無理っぽいから、先に""を\"に変換してあるとする。


# 4.エスケープ用に\"になっているの対応

$str ="'aaa\\'bb'";
print "= 4-1 =\n";
if ( $str =~ /('.*[^\\]')/ ) {
	print $1."\n";
} else {
	print "not found\n";
}


#4-1と同じ正規表現で、これも拾えるかな？
$str ="'','aa'";
print "= 4-2 =\n";
if ( $str =~ /('.*[^\\]')/ ) {
	print $1."\n";
} else {
	print "not found\n";
}
# 結論：'','aa' 変な拾い方した。
# でもこれは関係ないからよい


#4-1と同じ正規表現で、これは除外できるかな？
$str ="aa\','bb'";
print "= 4-3 =\n";
if ( $str =~ /('.*[^\\]')/ ) {
	print $1."\n";
} else {
	print "not found\n";
}
# 結論：ＮＧ ','bb' になった。
# はじめの'もエスケープ対応しなくちゃだった。



# 5.はじめの'もエスケープ対応

$str ="aa\\','bb'";
print "= 5 =\n";
if ( $str =~ /[^\\]('.*[^\\]')/ ) {
	print $1."\n";
} else {
	print "not found\n";
}

# 結論：ＯＫ 'bb'になった
# ()の外に[^\\]をつけないと、,'bb'になるから注意。

